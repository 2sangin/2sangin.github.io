---
layout: post
title: "오르막 수"
date: "2018-03-31 09:58:11 +0900"
---
# 1DP 1주 3일차
[문제 바로가기](https://www.acmicpc.net/problem/11057 "11057번: 오르막 수")

2자리일 때 각 10의 자리마다 11, 22, 33, ..., 99와 같은 경우, 3자리일 땐 각 100, 10의 자리마다 111, 222, 333, ..., 999와 같은 경우에만 오르막 수가 가능하다.  
2자리일 때 10의 자리가 1인 오르막 수는 10개, 2는 9개, ... 9는 1개이다.
3자리일 땐 100의 자리가 1인 오르막 수는 2자리의 총 갯수인 55개, 2인 오르막 수는 1의 갯수 55개에서 10의 자리가 1일 때가 제외되므로 45개이다. 이 같은 식으로 반복해보면 규칙이 일정해서 그 이후의 개수를 구하기 쉽다.

그렇게 구해놓고 보니까 각 N번째 자리의 값이 1일 때의 값의 증가 비율이 1 + 9/N배였다.
이로써 N=3일 때 100의 자리가 1 ~ 9일 때의 모든 개수를 셀 필요는 없어졌다.

자릿 수가 N일 때의 오르막 수의 개수를 A[N]이라고 하면,

> A[1] = 10,  
> A[N] = A[N - 1] * (1 + 9 / N)

이 된다.

문제는 N 값이 1,000까지 가능하다는 점이다. [스프레드 시트]로 위 과정을 전부 진행했는데 N=526일 때 JAVA long형의 최댓값을 넘는지는 정확히 안 따져봤으나 어쨌든 근처에 도달한다. N=527일 땐 확실히 넘어간다. 시간복잡도는 그래도 O(log n) 정도인게 맞나?

왠지 나머지 연산을 통해서 계속 값을 줄여주는 게 뭔가 있는 것 처럼 생각은 드는데, 그렇게 나머지 연산한 값에서는 이렇다할 규칙을 찾지 못 했다.


[스프레드 시트]: https://docs.google.com/spreadsheets/d/1unQrNOZ4UIZG0k2lYuAjju8aq2GnKGGbBZOyf5OcehY/edit "오르막 수"